\section{Colorizar}

\subsection{Código C}
	El código C se trata de una conjunción de ciclos, el exterior que recorre desde la segunda fila hasta la ante última,  y el interior que recorre desde la segunda columna hasta la última, dejando afuera a todos los bordes, tal como el enunciado pedía. \\ Luego en cada iteración del ciclo interior, que es donde se hacen las opearciones que modifican la imagen, lo que hacemos es crear un arreglo de unsinged chars, "res", que es  donde guardamos los máximos de cada canal en comparación a todos  los pixeles lindantes del píxel en el cual estemos parados (una matriz de 3x3).
\begin{itemize}
\item {Res $[$0$]$ $\leftarrow$ MaximoLindantesAzul}
\item {Res $[$1$]$ $\leftarrow$ MaximoLindantesVerde}
\item {Res $[$2$]$ $\leftarrow$ MaximoLindantesRojo}
\end{itemize}
Luego con estos tres valores calculamos el alpha correspondiente de cada canal por el cual vamos a multiplicar a cada uno. Y por último reescribimos el píxel final, en la imagen src con cada canal multiplicado por dicho alpha.

\subsection{Código ASM}
	El código en ASM se trata también de una conjunción de ciclos. El ciclo exterior recorre desde la segunda hasta la ante última fila, y el interior recorre las columnas desde la segunda hasta la ante última, pero saltando de a dos píxeles, que es la cantidad que procesamos simultaneamente con instruccciones SSE. \\
	El ciclo interior consta de dos partes, la primera es calcular un registro en el que en las primeras dos DW guardamos los máximos valores de cada canal entre los píxeles lindantes, en sus posiciones respectivas. Se vería asi:\\
\ Vamos a hacer referencia como "fruta" cuando un byte tenga información que no nos interesa.
\par{\textbf{XMM1:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$A_M{p2}$}{$R_M{p2}$}{$G_M{p2}$}{$B_M{p2}$}{$A_M{p1}$}{$R_M{p1}$}{$G_M{p1}$}{$B_M{p1}$}
	
 Luego con esta información lo que hacemos es duplicar dicho registro y calcular el máximo de los máximos. Lo que hacemos para lograr esto es shiftear un byte a la derecha al registro duplicado, cosa de poder ir comparando entre ellos a los valores máximos de cada canal, y finalmente reproducimos el valor del máximo entre los máximos en todas las posiciones. El seguimiento de esta operación sería la siguiente: 
\\Vamos a utilizar para esto los registros xmm1, y xmm2
\\
\par{\textbf{XMM2:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$A_M{p2}$}{$R_M{p2}$}{$G_M{p2}$}{$B_M{p2}$}{$A_M{p1}$}{$R_M{p1}$}{$G_M{p1}$}{$B_M{p1}$}
\par{\textbf{XMM1:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$A_M{p2}$}{$R_M{p2}$}{$G_M{p2}$}{$B_M{p2}$}{$A_M{p1}$}{$R_M{p1}$}{$G_M{p1}$}{$B_M{p1}$}
\par{shifteo un byte a la derecha xmm2 y hacemos pmaxub xmm1,xmm2  máximo entre ambos)}
\par{\textbf{XMM2:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$A_M{p2}$}{$R_M{p2}$}{$G_M{p2}$}{$B_M{p2}$}{$A_M{p1}$}{$R_M{p1}$}{$G_M{p1}$}{$B_M{p1}$}

\par{\textbf{XMM1:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$RG_M{p2}$}{$Fruta$}{$Fruta$}{$Fruta$}{$RG_M{p1}$}{$Fruta$}
\par {notar que varias casillas ahora tienen mas la asignación de "fruta", y esto no es porque no sepamos que hay dentro de cada una, sino que no es información relevante a nuestras operaciones y que sera pisada si es necesario dentro de pronto}
\par{luego volvemos a shiftear y repetir la operación pmaxub xmm1,xmm2  y queda: }

\par{\textbf{XMM2:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$A_M{p2}$}{$R_M{p2}$}{$G_M{p2}$}{$B_M{p2}$}{$A_M{p1}$}{$R_M{p1}$}{$G_M{p1}$}{$B_M{p1}$}

\par{\textbf{XMM1:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$RGB_{p2}$}{$Fruta$}{$Fruta$}{$Fruta$}{{\scriptsize $RGB_{Mp1}$}}
\par{por último con la instrucción pshuf, dejamos en xmm1 un registro con los máximos de los máximos representado de esta forma: }
\par{\textbf{XMM1:}}
\xmmb{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$Fruta$}{$RGB_{p2}$}{$RGB_{p2}$}{$RGB_{p2}$}{$RGB_{p2}$}{{\scriptsize $RGB_{Mp1}$}}{{\scriptsize $RGB_{Mp1}$}}{{\scriptsize $RGB_{Mp1}$}}{{\scriptsize $RGB_{Mp1}$}}


	
	
   Y en la segunda parte del código lo que queda es que a este registro con la info del máximo de los máximos, lo transformamos en un registro con un 1 en el byte donde va el canal que contiene a este máximo entre los máximos (de cada píxel). Y ceros en el resto. \\ Teniendo esto se puede apreciar en el código cómo nos armamos los alphas personalizados para cada píxel y terminamos multiplicandolos y reescribiendo ambos píxeles. \\
   Por último avanzamos nuestros currents sobre columnas en dos porque es la cantidad de píxeles que procesamos y  volvemos en caso de no haber terminado toda la fila a empezar el ciclo interior.
	
	
\subsection{Experimentación 1}

\subsubsection{Idea}
	El primer experimento al igua que en el resto de los filtros, vamos a realizar la comparaciones 
	de cantidad de ciclos, por pixel procesado,  entre los Codigos de C sin optimizar, C optimizado nivel 3, y Asm. En esto vamos a realizar tres comparaciones. La primera trata de comparar entre imagenes cuadradas, como evoluciona el rendimiento con el tamaño de imagen que le pasemos, y Como se ven con respecto a los otros codigos. La segunda comparacion trata de comparar imagenes con la misma cantidad d pixeles, pero con diferentes dimensiones. Y por ultimo comapramos rendimientos al tratar de imagenes con el mismo color en cada pixel.
	
	
\subsubsection{Hipotesis}
	En la primer comparacion esperamos como siempre que el codigo de asm sea el mas optimo, luego le siga el codigo en C optimizado, y por ultimo el codigo de C sin optimizar. \\ 
	En la segunda comparacion, se espera que sea similarla cantidad de ciclos por pixel que se obtiene porque el ciclo no busca ninguna optimizacion respecto al ancho o alto de la imagen, sino que procesa por igual a todos los pixeles.
	Y por ultimo en el tercer experimento suponemos lo mismo, no buscamos ninguna optimizacion con respecto a los valores de los pixeles adyacentes, sino que procesamos por igual a cada pixel indistintamente de su contexto, por lo que esperamos que los valores sean constantes.
	
\subsubsection{Resultados}

\begin{figure}[h!]
\centering
\captionsetup{justification=centering}
	\includegraphics[width = 15 cm, height = 8 cm]{imagenes/ImgCuadradas.jpg}
	\caption[center]{Gráfico de barras comparando las implementaciones y diversas optimizaciones.}
\end{figure}

\medskip\begin{figure}[h!]
\centering
\captionsetup{justification=centering}
	\includegraphics[width = 15 cm, height = 8 cm]{imagenes/DifDimensiones.jpg}
	\caption[center]{Gráfico de barras comparando las implementaciones y diversas optimizaciones.}
\end{figure}

\medskip\begin{figure}[h!]
\centering
\captionsetup{justification=centering}
	\includegraphics[width = 15 cm, height = 8 cm]{imagenes/mismoColor.jpg}
	\caption[center]{Gráfico de barras comparando las implementaciones y diversas optimizaciones.}
\end{figure}

\medskip

\subsubsection{Conclucion}
La conclucion que podemos sacar de estas imagenes, es que, en primer lugar, como dijimos en la hipotesis, que se termino corroborando, el codigo en C sin optimizar fue por lejos mas lento que los otros dos. Y el codigo en C optimizado por mas que mejoro muchisimo con respecto al anterior, siguio siendo mas lento que el codigo en asm. \\ Luego podemos ver que no nos confundimos tampoco en el momento de cambiar los tamaño de las imagenes pues los valores se mantuvieron bastantes constantes, y esto porque justamente no se cambia la cantidad de operaciones que se hace respecto a las dimensiones de las imagenes, siempre se mantiene segun la cantidad de pixeles. \\ Por ultimo sin embargo no llamo la atencion el experimento de correr los codigos con imagenes de un solo color. Lo que paso aca de extraño se que bueno los codigos en asm y en C -O3 se mantuvieron cosntantes a los desarrollados con imagenes comunes, sin embargo el codigo en C -O0 demostros una gran mejora respecto a su performance, la cual no podemos explicar bien el porque de ella, y de hecho esto tambien se ve en la primer imagen, donde el las imagenes de 4096x4096 el codigo en C -O0 mostro que mejoraba su rendimiento. Y la explicacion que le asignamos a eso es que justamente porque las imagenes que le pasamos tienen grandes secciones con pixeles del mismo color, porque son eexpanciones de una imagen de 512x512. Y se genera en estos fragmentos esta optimizacion que no podemos explicar sobre C -O0 en imagenes donde el color no cambia.

	

\subsection{Experimentacion 2}	

\subsubsection{Idea}
	El segundo experimento, es un experimento mas destructivo. Vamos a intentar molestar al jump predictor y ver como influye eso en la  performance del programa. 
	El experimento en si trata de agarrar un numero arbitrario desde los datos de entrada y en diferentes puntos de parada, ejecutar un control de flujo if then else, tal que dependiendo de ciertas condiciones random de este numero arbitrario, salte  a diferentes secciones del codigo. TOdo esto dispuesto de tal manera que sea transparente a la ejecucion final del programa, osea si el codigo sigue el camino del if no cambia a si siquue el camino del else.

\subsubsection{Hipotesis}
	Nuestra hipotesis es que justamente el codigo no modificado va a ser bastante mas optimo al codigo desarrollado con molestias para el jump predictor, porque en caso de funcionar estas, en cada ciclo estariamos haciendo que flushee el pipeline, y que pierda muchos ciclos de clock extra.
	
\subsubsection{Resutltados}

\medskip\begin{figure}[h!]
\centering
\captionsetup{justification=centering}
	\includegraphics[width = 15 cm, height = 8 cm]{imagenes/JumpPredictor.jpg}
	\caption[center]{Gráfico de barras comparando las implementaciones y diversas optimizaciones.}
\end{figure}

\medskip

\subsubsection{Conclucion}
Efectivamente los resultados fueron los esperados, por lo que nos llevamos como conclucion del experimento que influye mucho la arbitrareidad del flujo del programa que armes, si uno lo hace muy random como en este caso, por mas que no afecte a la complegidad total el programa tarda significativamente mas.

\subsection{Experimento 3}

\subsubsection{Idea}
En el tercer experimento vamos a ver hasta que punto es optimo aplicar la tecnica de unrolling sobre un codigo. Osea lo que planeamos hacer es correr el codigo de colorizar, sobre una imagen de 1024x1024, desenrrollando el ciclo interior, distinta cantidad de veces, vamos a empezar desenrrollando 16, luego 32, y luego completamente.

	   
\subsubsection{Hipotesis}
Lo que esperamos de este experimento es que el codigo desenrrollado 16 y 32 veces, mantenga el nivel de performance con el que demuestra normalmente, o un poco mas optimo, y esto porque en s\'i el codigo de colorizar lleva muchas instrucciones, por lo que los pasos que nos ahorramos al desenrrollar el codigo no es significativo en el total del programa. Sin embargo en el caso de desenrrollar todo el codigo, esperamos una mucha peor performance por parte del codigo y esto debido a que el tamaño del codigo aumentaria enrmomente su tamaño de modo que no entre en la memoria cache el mismo, y deba empezar a hacer lecturas de memoria para leer las instrucciones.
	
\subsubsection{Resultados}

\begin{figure}[h!]
\centering
\captionsetup{justification=centering}
	\includegraphics[width = 15 cm, height = 8 cm]{imagenes/unroll.jpg}
	\caption[center]{Gráfico de barras comparando las implementaciones y diversas optimizaciones.}
\end{figure}

\medskip

	
\subsubsection{Conclusión}
La conclucion que sacamos de este esxprimento es que la tecnica de desenrrollar codigo es efectiva para pequeños whiles, porq eliminas algunas instrucciones inecesarias, sin embargo ya para un while de un tamaño mayor a lo usual, la optimizacion generada por esto se diluye hasta el punto d  no notarse. Ademas de que efectivamente elementos como la memoria cache son limitantes aca, donde pasa que los problemas de lectura a memoria dejan de ser parte de como esta hecho el algoritmo y pasa a ser a simplemente poder leerlo. 
 
